/* suspend fun <T : Any> getAll(dataClass: KClass<T>, id: Long = 0L): List<T?> =
        withContext(Dispatchers.IO) {
            val tableName = dataClass.simpleName?.toLowerCase() ?: throw Exception("Table name not found")
            val selectAll = if (id == 0L) {
                """SELECT * FROM $tableName WHERE NOT deleted"""
            } else {
                """SELECT * FROM $tableName WHERE id = $id AND NOT deleted"""
            }

            val statement = DBManager.connection().prepareStatement(selectAll)
            val resultSet = statement.executeQuery()
            val objects = mutableListOf<T?>()

            while (resultSet.next()) {
                val constructor = dataClass.constructors.firstOrNull()
                val parameters = constructor?.parameters?.associateBy({ it.name }, { it.type.javaType })

                val values = hashMapOf<String, Any?>()
                parameters?.forEach { (name, type) ->
                    val value = when (type) {
                        Long::class.java -> resultSet.getLong(name)
                        String::class.java -> resultSet.getString(name)
                        Double::class.java -> resultSet.getDouble(name)
                        java.sql.Timestamp::class.java -> resultSet.getTimestamp(name)
                        Boolean::class.java -> resultSet.getBoolean(name)
                        else -> throw IllegalArgumentException("Unsupported property type $type")
                    }
                    values[name] = value
                }

                val obj = constructor?.callBy(values)
                objects.add(obj)
            }
            return@withContext objects
        }

    @OptIn(ExperimentalStdlibApi::class)
    suspend fun <T : Any> getAll(dataClass: KClass<T>, id: Long = 0L): List<T?> =
        withContext(Dispatchers.IO) {
            val tableName = dataClass.simpleName?.toLowerCase() ?: throw Exception("Table name not found")
            val selectAll = if (id == 0L) {
                """SELECT * FROM $tableName WHERE NOT deleted"""
            } else {
                """SELECT * FROM $tableName WHERE id = $id AND NOT deleted"""
            }

            val statement = DBManager.connection().prepareStatement(selectAll)
            val resultSet = statement.executeQuery()
            val objects = mutableListOf<T?>()

            while (resultSet.next()) {
                val constructor = dataClass.constructors.firstOrNull()
                val parameters = constructor?.parameters?.associateBy({ it.name }, { it.type.javaType })

                val values = hashMapOf<String, Any?>()
                parameters?.forEach { (name, type) ->
                    val value = when (val classifier = (type as java.lang.reflect.ParameterizedType).rawType as Class<*>) {
                        Long::class.java -> resultSet.getLong(name)
                        String::class.java -> resultSet.getString(name)
                        Double::class.java -> resultSet.getDouble(name)
                        java.sql.Timestamp::class.java -> resultSet.getTimestamp(name)
                        Boolean::class.java -> resultSet.getBoolean(name)
                        else -> throw IllegalArgumentException("Unsupported property type $classifier")
                    }
                    values[name] = value
                }

                val obj = constructor?.callBy(values)
                objects.add(obj)
            }
            return@withContext objects
        }
*/
    /*@OptIn(ExperimentalStdlibApi::class)
    suspend fun <T : Any> getAll(dataClass: KClass<T>, id: Long = 0L, tName: String? = null): List<T?> =
    withContext(Dispatchers.IO) {
        val tableName = tName ?: (dataClass.simpleName?.toLowerCase() ?: throw Exception("Table name not found"))
        val selectAll = if (id == 0L) {
            """SELECT * FROM $tableName WHERE NOT deleted"""
        } else {
            """SELECT * FROM $tableName WHERE id = $id AND NOT deleted"""
        }

        val statement = connection().prepareStatement(selectAll)
        val resultSet = statement.executeQuery()
        val objects = mutableListOf<T?>()

        while (resultSet.next()) {
            val constructor = dataClass.constructors.firstOrNull()
            val parameters = constructor?.parameters

            val values = mutableMapOf<KParameter, Any?>()
            parameters?.forEach { parameter ->
                val name = parameter.name ?: throw IllegalArgumentException("Parameter name is missing")
                val type = parameter.type.javaType

                val value = when (val classifier = (type as java.lang.reflect.ParameterizedType).rawType as Class<*>) {
                    Long::class.java -> resultSet.getLong(name)
                    String::class.java -> resultSet.getString(name)
                    Double::class.java -> resultSet.getDouble(name)
                    java.sql.Timestamp::class.java -> resultSet.getTimestamp(name)
                    Boolean::class.java -> resultSet.getBoolean(name)
                    else -> throw IllegalArgumentException("Unsupported property type $classifier")
                }
                values[parameter] = value
            }

            val obj = constructor?.callBy(values)
            objects.add(obj)
        }
        return@withContext objects
    }
*/

//
    suspend fun <T : Any> getAll(dataClass: KClass<T>, id: Long = 0L, tName: String? = null): List<T> =
    withContext(Dispatchers.IO) {
        val columnMap = getColumnMap(dataClass.java.javaClass)
        val tableName = tName ?: (dataClass.simpleName?.toLowerCase() ?: throw Exception("Table name not found"))
        val selectAll = if (id == 0L) {
            """SELECT * FROM $tableName WHERE NOT deleted"""
        } else {
            """SELECT * FROM $tableName WHERE id = $id AND NOT deleted"""
        }

        val statement = connection().prepareStatement(selectAll)
        val resultSet = statement.executeQuery()
        val items = mutableListOf<T>()


        while (resultSet.next()) {
            val constructor = dataClass.primaryConstructor
                ?: throw IllegalArgumentException("No primary constructor found")

            val parameters = constructor.parameters.map { param ->
                val columnName = param.name?.toLowerCase() ?: throw IllegalArgumentException("Column name not found")
                resultSet.getObject(columnName, columnMap)
            }.toTypedArray()

            val item = constructor.call(*parameters)
            items.add(item)
        }

        return@withContext items
    }

   /* fun getColumnMap(): Map<String, Class<*>> {
        return ProductTable::class.memberProperties.associate { prop ->
            prop.name to when (prop.returnType) {
                Long::class.starProjectedType.nullable -> Long::class.javaObjectType
                String::class.starProjectedType.nullable -> String::class.java
                Double::class.starProjectedType.nullable -> Double::class.javaObjectType
                Boolean::class.starProjectedType.nullable -> Boolean::class.javaObjectType
                Timestamp::class.starProjectedType.nullable -> Timestamp::class.java
                else -> throw IllegalArgumentException("Unsupported type: ${prop.returnType}")
            }
        }
    }*/

    /*fun getColumnMap(): Map<String, Class<*>> {
        return ProductTable::class.memberProperties.associate { prop ->
            prop.name to when {
                prop.returnType.isSubtypeOf(Long::class.starProjectedType) && prop.returnType.isMarkedNullable -> Long::class.javaObjectType
                prop.returnType.isSubtypeOf(String::class.starProjectedType) && prop.returnType.isMarkedNullable -> String::class.java
                prop.returnType.isSubtypeOf(Double::class.starProjectedType) && prop.returnType.isMarkedNullable -> Double::class.javaObjectType
                prop.returnType.isSubtypeOf(Boolean::class.starProjectedType) && prop.returnType.isMarkedNullable -> Boolean::class.javaObjectType
                prop.returnType.isSubtypeOf(Timestamp::class.starProjectedType) && prop.returnType.isMarkedNullable -> Timestamp::class.java
                else -> throw IllegalArgumentException("Unsupported type: ${prop.returnType}")
            }
        }
    }*/

    inline fun <reified T : Any> getColumnMap(clazz: Class<T>): Map<String, Class<*>> {
        return clazz.kotlin.memberProperties.associate { prop ->
            prop.name to when (prop.returnType) {
                Long::class.java -> Long::class.javaObjectType
                String::class.java -> String::class.java
                Double::class.java -> Double::class.javaObjectType
                Boolean::class.java -> Boolean::class.javaObjectType
                Timestamp::class.java -> Timestamp::class.java
                else -> throw IllegalArgumentException("Unsupported type: ${prop.returnType}")
            }
        }
    }

    /*
    inline fun <reified T : Any, reified R : Any> toDto(table: T): R? {
        val tableClass = T::class
        val dtoClass = try {
            Class.forName(tableClass.qualifiedName!!.replace("Table", "Dto")).kotlin
        } catch (e: ClassNotFoundException) {
            return null
        }


        val dtoConstructor = dtoClass.primaryConstructor ?: return null
        val dtoParameters = dtoConstructor.parameters.associateBy { it.name }
        val dtoValues = dtoParameters.mapValues { (name, parameter) ->
            val propertyName = name?.replace("Uz", "")?.replace("Ru", "")?.replace("En", "")
            val property = tableClass.memberProperties.find { it.name == propertyName }

            if (property != null && property.returnType.classifier == TextModel::class) {
                toTextModel(tableClass, table, propertyName!!)
            } else {
                property?.get(table)?.let {
                    if (it is String) {
                        it.trim()
                    } else {
                        it
                    }
                } ?: Mapper.getDefaultParameterValue(parameter, dtoClass)
            }
        }

        return dtoConstructor.callBy(dtoValues.filterKeys { it != null }.mapKeys {
            dtoConstructor.parameters.find { p -> p.name == it.key }!!
        }) as R
    }

    fun toTextModel(tableClass: KClass<*>, table: Any, propertyName: String): TextModel {
        val textModel = TextModel("", "", "")
        tableClass.memberProperties.filter { it.name.startsWith(propertyName) }.forEach { prop ->
            val lang = prop.name.takeLast(2)
            when (lang) {
                "Uz" -> textModel.uz = prop.get(table as Nothing)?.toString() ?: ""
                "Ru" -> textModel.ru = prop.get(table as Nothing)?.toString() ?: ""
                "En" -> textModel.eng = prop.get(table as Nothing)?.toString() ?: ""
            }
        }
        return textModel
    }

    inline fun <reified T : Any, reified R : Any> tooDto(table: T): R? {
        val tableClass = T::class
        val dtoClass = try {
            Class.forName(tableClass.qualifiedName!!.replace("Table", "Dto")).kotlin
        } catch (e: ClassNotFoundException) {
            return null
        }

        val dtoConstructor = dtoClass.primaryConstructor ?: return null
        val dtoParameters = dtoConstructor.parameters.associateBy { it.name }
        val dtoValues = dtoParameters.mapValues { (name, parameter) ->
            val propertyName = name?.replace("Uz", "")?.replace("Ru", "")?.replace("Eng", "")
            val property = tableClass.memberProperties.find { it.name == propertyName }

            if (property != null && property.returnType.classifier == TextModel::class) {
                val textModel = TextModel("", "", "")
                tableClass.memberProperties.filter { it.name.startsWith(propertyName ?: "") }.forEach { prop ->
                    val lang = prop.name.takeLast(2)
                    when (lang) {
                        "z" -> textModel.uz = prop.get(table).toString()
                        "Ru" -> textModel.ru = prop.get(table).toString()
                        "Eng" -> textModel.eng = prop.get(table).toString()
                    }
                }
                textModel
            } else {
                property?.get(table)?.let {
                    if (it is String) {
                        it.trim()
                    } else {
                        it
                    }
                } ?: getDefaultParameterValue(parameter, dtoClass)
            }
        }
        return dtoConstructor.callBy(dtoValues.filterKeys { it != null }.mapKeys {
            dtoConstructor.parameters.find { p -> p.name == it.key }!!
        }) as R
    }

    inline fun <reified T : Any> toTable(dto: T): Any? {
        val dtoClass = T::class
        val tableName = dtoClass.simpleName?.replace("Dto", "Table") ?: return null
        val tableClass = try {
            Class.forName(dtoClass.qualifiedName!!.replace("Dto", "Table")).kotlin
        } catch (e: ClassNotFoundException) {
            return null
        }

        val tableConstructor = tableClass.primaryConstructor ?: return null
        val tableParameters = tableConstructor.parameters.associateBy { it.name }
        val tableValues = tableParameters.mapValues { (name, parameter) ->
            val propertyName = name?.replace("Uz", "")?.replace("Ru", "")?.replace("Eng", "")
            dtoClass.memberProperties.find { it.name == propertyName }?.get(dto)?.let {
                if (it is String) {
                    it.trim()
                } else if (it is TextModel) {
                    when (name) {
                        "${propertyName}Uz" -> it.uz
                        "${propertyName}Ru" -> it.ru
                        "${propertyName}Eng" -> it.eng
                        else -> null
                    }
                } else {
                    it
                }
            } ?: getDefaultParameterValue(parameter, tableClass)
        }
        return tableConstructor.callBy(tableValues.filterKeys { it != null }.mapKeys {
            tableConstructor.parameters.find { p -> p.name == it.key }!! })
    }
    */

scp ./build/libs/lamenu-all.jar root@188.166.167.80:/root

